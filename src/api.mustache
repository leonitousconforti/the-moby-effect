// spell-checker: disable
{{>licenseInfo}}

import * as url from "node:url";

const BASE_PATH = "{{{basePath}}}"

const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

export interface FetchArguments {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    override name = "RequiredError"
    constructor(public field: string, message?: string) {
        super(message);
    }
}

{{#models}}
{{#model}}{{#isEnum}}{{>modelEnum}}{{/isEnum}}{{^isEnum}}{{>modelGeneric}}{{/isEnum}}{{/model}}
{{/models}}
{{#apiInfo}}{{#apis}}{{#operations}}
{{#operation}}
/**
* {{classname}} {{nickname}} fetch parameter creator
*
{{#summary}}
* @summary {{&summary}} fetch parameter creator
{{/summary}}
{{#allParams}}
* @param {{=<% %>=}}{<%&dataType%>}<%={{ }}=%> {{^required}}[{{/required}}{{paramName}}{{^required}}]{{/required}} {{description}}
{{/allParams}}
* @param {*} [options] Override http request option.
* @throws {RequiredError}
*/
export const {{nickname}}FetchParameterCreator = ({{#allParams}}{{paramName}}{{^required}}?{{/required}}: {{{dataType}}}, {{/allParams}}options: any = {}): FetchArguments => {
{{#allParams}}
{{#required}}
    // verify required parameter '{{paramName}}' is not null or undefined
    if ({{paramName}} === null || {{paramName}} === undefined) {
        throw new RequiredError('{{paramName}}','Required parameter {{paramName}} was null or undefined when calling {{nickname}}.');
    }
{{/required}}
{{/allParams}}
    const localvariablePath = `{{{path}}}`{{#pathParams}}
        .replace(`{${"{{baseName}}"}}`, encodeURIComponent(String({{paramName}}))){{/pathParams}};
    const localvariableUrlObject = url.parse(localvariablePath, true);
    const localvariableRequestOptions = Object.assign({ method: '{{httpMethod}}' }, options);
    const localvariableHeaderParameter = {} as any;
    const localvariableQueryParameter = {} as any;
{{#hasFormParams}}
    const localvariableFormParameters = new url.URLSearchParams();
{{/hasFormParams}}

{{#queryParams}}
    {{#isListContainer}}
    if ({{paramName}}) {
    {{#isCollectionFormatMulti}}
        localvariableQueryParameter['{{baseName}}'] = {{paramName}};
    {{/isCollectionFormatMulti}}
    {{^isCollectionFormatMulti}}
        localvariableQueryParameter['{{baseName}}'] = {{paramName}}.join(COLLECTION_FORMATS["{{collectionFormat}}"]);
    {{/isCollectionFormatMulti}}
    }
    {{/isListContainer}}
    {{^isListContainer}}
    if ({{paramName}} !== undefined) {
        {{#isDateTime}}
        localvariableQueryParameter['{{baseName}}'] = ({{paramName}} as any).toISOString();
        {{/isDateTime}}
        {{^isDateTime}}
        {{#isDate}}
        localvariableQueryParameter['{{baseName}}'] = ({{paramName}} as any instanceof Date) ?
            ({{paramName}} as any).toISOString().substr(0,10) :
            {{paramName}};
        {{/isDate}}
        {{^isDate}}
        localvariableQueryParameter['{{baseName}}'] = {{paramName}};
        {{/isDate}}
        {{/isDateTime}}
    }
    {{/isListContainer}}

{{/queryParams}}
{{#headerParams}}
    {{#isListContainer}}
    if ({{paramName}}) {
        localvariableHeaderParameter['{{baseName}}'] = {{paramName}}.join(COLLECTION_FORMATS["{{collectionFormat}}"]));
    }
    {{/isListContainer}}
    {{^isListContainer}}
    if ({{paramName}} !== undefined && {{paramName}} !== null) {
        localvariableHeaderParameter['{{baseName}}'] = String({{paramName}});
    }
    {{/isListContainer}}

{{/headerParams}}
{{#formParams}}
    {{#isListContainer}}
    if ({{paramName}}) {
    {{#isCollectionFormatMulti}}
        {{paramName}}.forEach((element) => {
            localvariableFormParameters.append('{{baseName}}', element as any);
        })
    {{/isCollectionFormatMulti}}
    {{^isCollectionFormatMulti}}
            localvariableFormParameters.set('{{baseName}}', {{paramName}}.join(COLLECTION_FORMATS["{{collectionFormat}}"]));
    {{/isCollectionFormatMulti}}
    }
    {{/isListContainer}}
    {{^isListContainer}}
    if ({{paramName}} !== undefined) {
        localvariableFormParameters.set('{{baseName}}', {{paramName}} as any);
    }
    {{/isListContainer}}

{{/formParams}}
{{#hasFormParams}}
    localvariableHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

{{/hasFormParams}}
{{#bodyParam}}
    {{^consumes}}
    localvariableHeaderParameter['Content-Type'] = 'application/json';
    {{/consumes}}
    {{#consumes.0}}
    localvariableHeaderParameter['Content-Type'] = '{{{mediaType}}}';
    {{/consumes.0}}

{{/bodyParam}}
    localvariableUrlObject.query = Object.assign({}, localvariableUrlObject.query, localvariableQueryParameter, options.query);
    // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
    localvariableUrlObject.search = null;
    localvariableRequestOptions.headers = Object.assign({}, localvariableHeaderParameter, options.headers);
{{#hasFormParams}}
    localvariableRequestOptions.body = localvariableFormParameters.toString();
{{/hasFormParams}}
{{#bodyParam}}
    const needsSerialization = (<any>"{{dataType}}" !== "string") || localvariableRequestOptions.headers['Content-Type'] === 'application/json';
    localvariableRequestOptions.body =  needsSerialization ? JSON.stringify({{paramName}} || {}) : ({{paramName}} || "");
{{/bodyParam}}

    return {
        url: url.format(localvariableUrlObject),
        options: localvariableRequestOptions,
    };
}
{{/operation}}

{{#operation}}
/**
* {{&notes}}
{{#summary}}
* @summary {{&summary}}
{{/summary}}
{{#allParams}}
* @param {{=<% %>=}}{<%&dataType%>}<%={{ }}=%> {{^required}}[{{/required}}{{paramName}}{{^required}}]{{/required}} {{description}}
{{/allParams}}
* @param {*} [options] Override http request option.
* @throws {RequiredError}
*/
export const {{nickname}} = ({{#allParams}}{{paramName}}{{^required}}?{{/required}}: {{{dataType}}}, {{/allParams}}options?: any): (fetch: FetchAPI, basePath?: string) => Promise<{{#returnType}}{{{returnType}}}{{/returnType}}{{^returnType}}Response{{/returnType}}> => {
    const localvariableFetchArguments = {{nickname}}FetchParameterCreator({{#allParams}}{{paramName}}, {{/allParams}}options);
    return (fetch: FetchAPI, basePath: string = BASE_PATH) => {
        return fetch(basePath + localvariableFetchArguments.url, localvariableFetchArguments.options).then((response) => {
            if (response.status >= 200 && response.status < 300) {
                return response{{#returnType}}.json() as Promise<{{&returnType}}>{{/returnType}};
            } else {
                throw response;
            }
        });
    };
}
{{/operation}}

{{#withInterfaces}}
/**
 * {{classname}} - interface{{#description}}
 * {{&description}}{{/description}}
 * @export
 * @interface {{classname}}
 */
export interface {{classname}}Interface {
{{#operation}}
    /**
     * {{&notes}}
     {{#summary}}
     * @summary {{&summary}}
     {{/summary}}
     {{#allParams}}
     * @param {{=<% %>=}}{<%&dataType%>}<%={{ }}=%> {{^required}}[{{/required}}{{paramName}}{{^required}}]{{/required}} {{description}}
     {{/allParams}}
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof {{classname}}Interface
     */
    {{nickname}}({{#allParams}}{{paramName}}{{^required}}?{{/required}}: {{{dataType}}}, {{/allParams}}options?: any): Promise<{{#returnType}}{{{returnType}}}{{/returnType}}{{^returnType}}{}{{/returnType}}>;

{{/operation}}
}

{{/withInterfaces}}
{{/operations}}{{/apis}}{{/apiInfo}}
