// spell-checker: disable

import { Schema, ParseResult } from "@effect/schema";
import { Effect, Context, Data, Layer, identity } from "effect";
import * as NodeHttp from "@effect/platform-node/HttpClient";

import { MobyConnectionOptions, makeDispatcher, makeUrl } from "./fetch.js";

import {
    any as anySchema,
    array as arraySchema,
    record as recordSchema,
    Date as DateSchema,
    string as stringSchema,
    number as numberSchema,
    boolean as booleanSchema,
    unknown as unknownSchema,
} from "@effect/schema/Schema";

const BASE_PATH = "{{{basePath}}}"

const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

{{#models}}
{{#model}}{{#isEnum}}{{>modelEnum}}{{/isEnum}}{{^isEnum}}{{>modelGeneric}}{{/isEnum}}{{/model}}
{{/models}}
// section: api
{{#apiInfo}}{{#apis}}{{#operations}}{{#operation}}
export class {{nickname}}Error extends Data.TaggedError("{{nickname}}Error")<{ message: string }> {}{{/operation}}{{/operations}}{{/apis}}{{/apiInfo}}

{{#apiInfo}}{{#apis}}{{#operations}}
{{#operation}}
/**
* {{&notes}}
{{#summary}}
* @summary {{&summary}}
{{/summary}}
{{#allParams}}
* @param {{=<% %>=}}{<%&dataType%>}<%={{ }}=%> {{^required}}[{{/required}}{{paramName}}{{^required}}]{{/required}} {{description}}
{{/allParams}}
*/
export const {{nickname}} = (mobyConnectionOptions: MobyConnectionOptions{{#allParams}}, {{paramName}}{{^required}}?{{/required}}: {{{dataType}}}{{/allParams}}): Effect.Effect<never, {{nickname}}Error | NodeHttp.error.HttpClientError {{#bodyParam}}| NodeHttp.body.BodyError {{/bodyParam}}| ParseResult.ParseError, {{#returnType}}Readonly<{{{returnType}}}>{{/returnType}}{{^returnType}}void{{/returnType}}> => Effect.gen(function* (_: Effect.Adapter) {
{{#allParams}}
{{#required}}
    if ({{paramName}} === null || {{paramName}} === undefined) {
        yield* _(new {{nickname}}Error({ message: "Required parameter {{paramName}} was null or undefined" }));
    }

{{/required}}
{{/allParams}}
    const endpoint: string = `${BASE_PATH}{{{path}}}`{{#pathParams}}.replace(`{${"{{baseName}}"}}`, encodeURIComponent(String({{paramName}}))){{/pathParams}};
    return NodeHttp.request.make("{{httpMethod}}")(endpoint);
})
{{#queryParams}}
{{#isListContainer}}
{{#isCollectionFormatMulti}}
.pipe(Effect.map(NodeHttp.request.setUrlParam("{{baseName}}", String({{paramName}}))))
{{/isCollectionFormatMulti}}
{{^isCollectionFormatMulti}}
.pipe(Effect.map(NodeHttp.request.setUrlParam("{{baseName}}", ({{paramName}} || []).join(COLLECTION_FORMATS["{{collectionFormat}}"]))))
{{/isCollectionFormatMulti}}
{{/isListContainer}}
{{^isListContainer}}
.pipe(Effect.map({{paramName}} === undefined ? identity : NodeHttp.request.setUrlParam("{{baseName}}", String({{paramName}}))))
{{/isListContainer}}
{{/queryParams}}
{{#headerParams}}
.pipe(Effect.map(NodeHttp.request.setHeader("{{baseName}}", String({{paramName}}))))
{{/headerParams}}
{{#bodyParam}}
{{^consumes}}
.pipe(Effect.map(NodeHttp.request.setHeader("Content-Type", "application/json")))
{{/consumes}}
{{#consumes.0}}
.pipe(Effect.map(NodeHttp.request.setHeader("Content-Type", "{{{mediaType}}}")))
{{/consumes.0}}
.pipe(
    Effect.flatMap((clientRequest) => {
        const needsSerialization =
            ("{{dataType}}" as unknown) !== "string" ||
            clientRequest.headers["Content-Type"] === "application/json";

        return needsSerialization
            ? NodeHttp.request.jsonBody(clientRequest, {{paramName}})
            : Effect.succeed(NodeHttp.request.textBody(clientRequest, ({{paramName}} as unknown as string) || ""));
    })
)
{{/bodyParam}}
.pipe(
    Effect.map(NodeHttp.request.prependUrl(makeUrl(mobyConnectionOptions))),
    Effect.flatMap(NodeHttp.client.fetchOk(makeDispatcher(mobyConnectionOptions)))
    {{#returnType}},Effect.flatMap(NodeHttp.response.schemaBodyJson({{{returnType}}}Schema)){{/returnType}}
)

{{/operation}}
{{/operations}}{{/apis}}{{/apiInfo}}

export interface IMobyService {
{{#apiInfo}}{{#apis}}{{#operations}}{{#operation}}readonly {{nickname}}: (...args: Parameters<typeof {{nickname}}> extends [MobyConnectionOptions, ...infer U] ? U : never) => ReturnType<typeof {{nickname}}>;
{{/operation}}{{/operations}}{{/apis}}{{/apiInfo}}
}

export const DefaultMobyClient: Context.Tag<IMobyService, IMobyService> = Context.Tag<IMobyService>(Symbol.for("@the-moby-effect/DefaultMobyClient"));

const instanciatedClientTags = new Set<Context.Tag<IMobyService, IMobyService>>();
export class clientAlreadyInstaniated extends Data.TaggedError("MobyClientAlreadyInstaniated")<{ message: string }> {}

export const makeMobyService = (
    mobyConnectionOptions?: MobyConnectionOptions | undefined,
    contextTag: Context.Tag<IMobyService, IMobyService> = DefaultMobyClient
): Layer.Layer<never, clientAlreadyInstaniated, IMobyService> => {
    const localmobyConnectionOptions =
        mobyConnectionOptions ||
        ({
            protocol: "unix",
            socketPath: "/var/run/docker.sock",
        } as MobyConnectionOptions);

    if (instanciatedClientTags.has(contextTag)) {
        return Layer.fail(
            new clientAlreadyInstaniated({
                message: `A client has already been instanciated for tag ${contextTag.identifier}`,
            })
        );
    }

    return Layer.succeed(
        contextTag,
        contextTag.of({
{{#apiInfo}}{{#apis}}{{#operations}}{{#operation}}{{nickname}}: (...args: Parameters<typeof {{nickname}}> extends [MobyConnectionOptions, ...infer U] ? U : never) => {{nickname}}(localmobyConnectionOptions, ...args),
{{/operation}}{{/operations}}{{/apis}}{{/apiInfo}}
        })
    );
}
