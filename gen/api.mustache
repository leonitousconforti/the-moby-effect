// spell-checker: disable

import http from "node:http";
import https from "node:https";

import * as ssh2 from "ssh2";
import * as Schema from "@effect/schema/Schema";
import * as ParseResult from "@effect/schema/ParseResult";
import * as NodeHttp from "@effect/platform-node/HttpClient";
import { Context, Data, Effect, Layer, Match, Scope, identity, pipe } from "effect";

import {
    any as anySchema,
    array as arraySchema,
    record as recordSchema,
    Date as DateSchema,
    string as stringSchema,
    number as numberSchema,
    boolean as booleanSchema,
    unknown as unknownSchema,
} from "@effect/schema/Schema";

export type MobyConnectionOptions =
    | { protocol: "http"; host: string; port: number }
    | { protocol: "https"; host: string; port: number; cert: string; ca: string; key: string }
    | ({ protocol: "ssh" } & ssh2.ConnectConfig)
    | { protocol: "unix"; socketPath: string };

const BASE_PATH = "/v1.43";

const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

const addHeader = NodeHttp.request.setHeader;

const addQueryParameter = (
    key: string,
    value: unknown | unknown[] | undefined
): ((self: NodeHttp.request.ClientRequest) => NodeHttp.request.ClientRequest) =>
    value === undefined || (Array.isArray(value) && value.length === 0)
        ? identity
        : NodeHttp.request.setUrlParam(key, String(value));

const setBody =
    (
        body: unknown,
        datatype: string
    ): ((
        clientRequest: NodeHttp.request.ClientRequest
    ) => Effect.Effect<never, NodeHttp.body.BodyError, NodeHttp.request.ClientRequest>) =>
    (clientRequest) => {
        const needsSerialization: boolean =
            datatype !== "string" || clientRequest.headers["Content-Type"] === "application/json";

        return needsSerialization
            ? NodeHttp.request.jsonBody(clientRequest, body)
            : Effect.succeed(NodeHttp.request.textBody(clientRequest, (body as unknown as string) || ""));
    };

{{#models}}
{{#model}}{{#isEnum}}{{>modelEnum}}{{/isEnum}}{{^isEnum}}{{>modelGeneric}}{{/isEnum}}{{/model}}
{{/models}}
// section: api
{{#apiInfo}}{{#apis}}{{#operations}}{{#operation}}
export class {{nickname}}Error extends Data.TaggedError("{{nickname}}Error")<{ message: string }> {}{{/operation}}{{/operations}}{{/apis}}{{/apiInfo}}

const MobyConnectionAgent = Context.Tag<IMobyConnectionAgent>(Symbol.for("@the-moby-effect/MobyConnectionAgent"));
export interface IMobyConnectionAgent extends NodeHttp.nodeClient.HttpAgent {
    readonly _: unknown;
}

{{#apiInfo}}{{#apis}}{{#operations}}
{{#operation}}
/**
* {{&notes}}
{{#summary}}
* @summary {{&summary}}
{{/summary}}
{{#allParams}}
* @param {{=<% %>=}}{<%&dataType%>}<%={{ }}=%> {{^required}}[{{/required}}{{paramName}}{{^required}}]{{/required}} {{description}}
{{/allParams}}
*/
export const {{nickname}} = ({{#allParams}}{{paramName}}{{^required}}?{{/required}}: {{{dataType}}}, {{/allParams}}): Effect.Effect<IMobyConnectionAgent, {{nickname}}Error | NodeHttp.error.RequestError | NodeHttp.error.ResponseError {{#bodyParam}} | NodeHttp.body.BodyError{{/bodyParam}} {{#returnType}} | ParseResult.ParseError{{/returnType}}, {{#returnType}}Readonly<{{{returnType}}}>{{/returnType}}{{^returnType}}void{{/returnType}}> => Effect.gen(function* (_: Effect.Adapter) {
{{#allParams}}
{{#required}}
    if ({{paramName}} === null || {{paramName}} === undefined) {
        yield* _(new {{nickname}}Error({ message: "Required parameter {{paramName}} was null or undefined" }));
    }

{{/required}}
{{/allParams}}
    const endpoint: string = `${BASE_PATH}{{{path}}}`;
    const method: "GET" | "HEAD" | "POST" | "PUT" | "DELETE" | "PATCH" | "OPTIONS" = "{{httpMethod}}";
    const sanitizedEndpoint: string = endpoint{{#pathParams}}.replace(`{${"{{baseName}}"}}`, encodeURIComponent(String({{paramName}}))){{/pathParams}};

    const agent: IMobyConnectionAgent = yield* _(MobyConnectionAgent);
    const client: NodeHttp.client.Client.Default = yield* _(
        NodeHttp.nodeClient.make.pipe(Effect.provideService(NodeHttp.nodeClient.HttpAgent, agent))
    );

    return NodeHttp.request
        .make(method)(sanitizedEndpoint)
        .pipe(NodeHttp.request.prependUrl("http://0.0.0.0"))
        {{#headerParams}}
        .pipe(addHeader("{{baseName}}", String({{paramName}})))
        {{/headerParams}}
        {{#queryParams}}
        {{#isListContainer}}
        {{#isCollectionFormatMulti}}
        .pipe(addQueryParameter("{{baseName}}", {{paramName}}))
        {{/isCollectionFormatMulti}}
        {{^isCollectionFormatMulti}}
        .pipe(addQueryParameter("{{baseName}}", ({{paramName}} || []).join(COLLECTION_FORMATS["{{collectionFormat}}"])))
        {{/isCollectionFormatMulti}}
        {{/isListContainer}}
        {{^isListContainer}}
        .pipe(addQueryParameter("{{baseName}}", {{paramName}}))
        {{/isListContainer}}
        {{/queryParams}}
        {{#bodyParam}}
        {{^consumes}}
        .pipe(addHeader("Content-Type", "application/json"))
        {{/consumes}}
        {{#consumes.0}}
        .pipe(addHeader("Content-Type", "{{{mediaType}}}"))
        {{/consumes.0}}
        .pipe(setBody({{paramName}}, "{{dataType}}"))
        .pipe(Effect.flatMap(client.pipe(NodeHttp.client.filterStatusOk)))
        {{/bodyParam}}
        {{^bodyParam}}
        .pipe(client)
        {{/bodyParam}}
        {{#returnType}}
        .pipe(Effect.flatMap(NodeHttp.response.schemaBodyJson({{{returnType}}}Schema)))
        {{/returnType}}
        .pipe(Effect.orElseFail(() => new {{nickname}}Error({ message: "Http request failed" })));
    }).pipe(Effect.flatten).pipe(Effect.scoped);

{{/operation}}
{{/operations}}{{/apis}}{{/apiInfo}}

type WithConnectionAgentProvided<Function_> = Function_ extends (
    ...arguments_: infer U
) => Effect.Effect<infer R, infer E, infer A>
    ? (...arguments_: U) => Effect.Effect<Exclude<R, IMobyConnectionAgent>, E, A>
    : never;

export interface IMobyService {
{{#apiInfo}}{{#apis}}{{#operations}}{{#operation}}readonly {{nickname}}: WithConnectionAgentProvided<typeof {{nickname}}>;{{/operation}}{{/operations}}{{/apis}}{{/apiInfo}}
    readonly getAgent: () => Effect.Effect<Scope.Scope, never, NodeHttp.nodeClient.HttpAgent>;
}

const instanciatedClientTags = new Set<`${string}MobyClient`>();
export class MobyClientAlreadyInstantiated extends Data.TaggedError("MobyClientAlreadyInstantiated")<{
    message: string;
}> {}

export const makeMobyLayer = <ContextIdentifier extends `${string}MobyClient`>(
    contextIdentifier: ContextIdentifier,
    mobyConnectionOptions?: MobyConnectionOptions | undefined
): [
    contextTag: Context.Tag<ContextIdentifier, IMobyService>,
    layer: Layer.Layer<never, MobyClientAlreadyInstantiated, ContextIdentifier>,
] => {
    if (instanciatedClientTags.has(contextIdentifier)) {
        return [
            Context.Tag(),
            Layer.fail(new MobyClientAlreadyInstantiated({ message: "Client already instantiated" })),
        ];
    }

    const localMobyConnectionOptions: MobyConnectionOptions =
        mobyConnectionOptions ||
        ({
            protocol: "unix",
            socketPath: "/var/run/docker.sock",
        } as MobyConnectionOptions);

    const agentOptions: http.AgentOptions | https.AgentOptions = pipe(
        Match.value<MobyConnectionOptions>(localMobyConnectionOptions),
        Match.when({ protocol: "unix" }, (options) => ({ socketPath: options.socketPath })),
        Match.orElse((options) => ({ host: options.host, port: options.port }))
    ) as http.AgentOptions | https.AgentOptions;

    const getAgent = (): Effect.Effect<Scope.Scope, never, NodeHttp.nodeClient.HttpAgent> =>
        NodeHttp.nodeClient.makeAgent(agentOptions);

    const agentLayerContextTag: Context.Tag<NodeHttp.nodeClient.HttpAgent, NodeHttp.nodeClient.HttpAgent> =
        Context.Tag<NodeHttp.nodeClient.HttpAgent>();

    const agentLayer: Layer.Layer<never, never, NodeHttp.nodeClient.HttpAgent> = Layer.scoped(
        agentLayerContextTag,
        getAgent()
    );

    const projectedLayer: Layer.Layer<never, never, IMobyConnectionAgent> = Layer.project(
        agentLayer,
        agentLayerContextTag,
        MobyConnectionAgent,
        (_) => ({ ..._, _: 69 })
    );

    const contextTag: Context.Tag<ContextIdentifier, IMobyService> = Context.Tag<ContextIdentifier, IMobyService>();

    const layer = Layer.succeed(
        contextTag,
        contextTag.of({
            {{#apiInfo}}{{#apis}}{{#operations}}{{#operation}}{{nickname}}: (...arguments_) => {{nickname}}(...arguments_).pipe(Effect.provide(projectedLayer)),{{/operation}}{{/operations}}{{/apis}}{{/apiInfo}}
            getAgent,
        })
    );

    return [contextTag, layer];
};
