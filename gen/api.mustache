// spell-checker: disable

import * as ssh2 from "ssh2";
import * as Schema from "@effect/schema/Schema";
import * as NodeHttp from "@effect/platform-node/HttpClient";
import { Effect, Context, Data, Layer, identity } from "effect";

import {
    any as anySchema,
    array as arraySchema,
    record as recordSchema,
    Date as DateSchema,
    string as stringSchema,
    number as numberSchema,
    boolean as booleanSchema,
    unknown as unknownSchema,
} from "@effect/schema/Schema";

export type MobyConnectionOptions =
    | { protocol: "http"; host: string; port: number }
    | { protocol: "https"; host: string; port: number }
    | ({ protocol: "ssh" } & ssh2.ConnectConfig)
    | { protocol: "unix"; socketPath: string };

const BASE_PATH = "/v1.43";

const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

const addHeader = NodeHttp.request.setHeader;

const addQueryParameter = (
    key: string | undefined,
    value: string
): ((self: NodeHttp.request.ClientRequest) => NodeHttp.request.ClientRequest) =>
    key === undefined ? identity : NodeHttp.request.setUrlParam(key, value);

const setBody =
    (
        body: unknown,
        datatype: string
    ): ((
        clientRequest: NodeHttp.request.ClientRequest
    ) => Effect.Effect<never, NodeHttp.body.BodyError, NodeHttp.request.ClientRequest>) =>
    (clientRequest) => {
        const needsSerialization: boolean =
            datatype !== "string" || clientRequest.headers["Content-Type"] === "application/json";

        return needsSerialization
            ? NodeHttp.request.jsonBody(clientRequest, body)
            : Effect.succeed(NodeHttp.request.textBody(clientRequest, (body as unknown as string) || ""));
    };

{{#models}}
{{#model}}{{#isEnum}}{{>modelEnum}}{{/isEnum}}{{^isEnum}}{{>modelGeneric}}{{/isEnum}}{{/model}}
{{/models}}
// section: api
{{#apiInfo}}{{#apis}}{{#operations}}{{#operation}}
export class {{nickname}}Error extends Data.TaggedError("{{nickname}}Error")<{ message: string }> {}{{/operation}}{{/operations}}{{/apis}}{{/apiInfo}}

{{#apiInfo}}{{#apis}}{{#operations}}
{{#operation}}
/**
* {{&notes}}
{{#summary}}
* @summary {{&summary}}
{{/summary}}
{{#allParams}}
* @param {{=<% %>=}}{<%&dataType%>}<%={{ }}=%> {{^required}}[{{/required}}{{paramName}}{{^required}}]{{/required}} {{description}}
{{/allParams}}
*/
export const {{nickname}} = ({{#allParams}}{{paramName}}{{^required}}?{{/required}}: {{{dataType}}}, {{/allParams}}): Effect.Effect<NodeHttp.nodeClient.HttpAgent, {{nickname}}Error, {{#returnType}}Readonly<{{{returnType}}}>{{/returnType}}{{^returnType}}void{{/returnType}}> => Effect.gen(function* (_: Effect.Adapter) {
{{#allParams}}
{{#required}}
    if ({{paramName}} === null || {{paramName}} === undefined) {
        yield* _(new {{nickname}}Error({ message: "Required parameter {{paramName}} was null or undefined" }));
    }

{{/required}}
{{/allParams}}
    const endpoint: string = `${BASE_PATH}{{{path}}}`;
    const method: "GET" | "HEAD" | "POST" | "PUT" | "DELETE" | "PATCH" | "OPTIONS" = "{{httpMethod}}";
    const sanitizedEndpoint: string = endpoint{{#pathParams}}.replace(`{${"{{baseName}}"}}`, encodeURIComponent(String({{paramName}}))){{/pathParams}};
    const client: NodeHttp.client.Client.Default = yield* _(NodeHttp.nodeClient.make);

    return NodeHttp.request
        .make(method)(sanitizedEndpoint)
        {{#headerParams}}
        .pipe(addHeader("{{baseName}}", String({{paramName}})))
        {{/headerParams}}
        {{#queryParams}}
        {{#isListContainer}}
        {{#isCollectionFormatMulti}}
        .pipe(addQueryParameter("{{baseName}}", String({{paramName}})))
        {{/isCollectionFormatMulti}}
        {{^isCollectionFormatMulti}}
        .pipe(addQueryParameter("{{baseName}}", ({{paramName}} || []).join(COLLECTION_FORMATS["{{collectionFormat}}"])))
        {{/isCollectionFormatMulti}}
        {{/isListContainer}}
        {{^isListContainer}}
        .pipe(addQueryParameter("{{baseName}}", String({{paramName}})))
        {{/isListContainer}}
        {{/queryParams}}
        {{#bodyParam}}
        {{^consumes}}
        .pipe(addHeader("Content-Type", "application/json"))
        {{/consumes}}
        {{#consumes.0}}
        .pipe(addHeader("Content-Type", "{{{mediaType}}}"))
        {{/consumes.0}}
        .pipe(setBody({{paramName}}, "{{dataType}}"))
        .pipe(Effect.flatMap(client))
        {{/bodyParam}}
        {{^bodyParam}}
        .pipe(client)
        {{/bodyParam}}
        {{#returnType}}
        .pipe(Effect.flatMap(NodeHttp.response.schemaBodyJson({{{returnType}}}Schema)))
        {{/returnType}}
        .pipe(Effect.orElseFail(() => new {{nickname}}Error({ message: "Http request failed" })));
    }).pipe(Effect.flatten);

{{/operation}}
{{/operations}}{{/apis}}{{/apiInfo}}

export interface IMobyService {
{{#apiInfo}}{{#apis}}{{#operations}}{{#operation}}readonly {{nickname}}: typeof {{nickname}};{{/operation}}{{/operations}}{{/apis}}{{/apiInfo}}
}

export const DefaultMobyClient: Context.Tag<IMobyService, IMobyService> = Context.Tag<IMobyService>(Symbol.for("@the-moby-effect/DefaultMobyClient"));

const instanciatedClientTags = new Set<Context.Tag<IMobyService, IMobyService>>();
export class clientAlreadyInstaniated extends Data.TaggedError("MobyClientAlreadyInstaniated")<{ message: string }> {}

export const makeMobyService = (
    mobyConnectionOptions?: MobyConnectionOptions | undefined,
    contextTag: Context.Tag<IMobyService, IMobyService> = DefaultMobyClient
): Layer.Layer<never, clientAlreadyInstaniated, IMobyService> => {
    const localmobyConnectionOptions =
        mobyConnectionOptions ||
        ({
            protocol: "unix",
            socketPath: "/var/run/docker.sock",
        } as MobyConnectionOptions);

    if (instanciatedClientTags.has(contextTag)) {
        return Layer.fail(
            new clientAlreadyInstaniated({
                message: `A client has already been instanciated for tag ${contextTag.identifier}`,
            })
        );
    }

    return Layer.succeed(
        contextTag,
        contextTag.of({
{{#apiInfo}}{{#apis}}{{#operations}}{{#operation}}{{nickname}},{{/operation}}{{/operations}}{{/apis}}{{/apiInfo}}
        })
    );
}
