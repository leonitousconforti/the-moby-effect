// spell-checker: disable

import "./fetch.js";
import { Schema, ParseResult } from "@effect/schema";
import * as Http from "@effect/platform/HttpClient";
import { Effect, Context, Data, Layer, identity } from "effect";
import { DockerConnectionOptions, makeDispatcher, makeUrl } from "./fetch.js";

import {
    any as anySchema,
    array as arraySchema,
    record as recordSchema,
    Date as DateSchema,
    string as stringSchema,
    number as numberSchema,
    boolean as booleanSchema,
    unknown as unknownSchema,
} from "@effect/schema/Schema";

const BASE_PATH = "{{{basePath}}}"

const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

{{#models}}
{{#model}}{{#isEnum}}{{>modelEnum}}{{/isEnum}}{{^isEnum}}{{>modelGeneric}}{{/isEnum}}{{/model}}
{{/models}}
// section: api
{{#apiInfo}}{{#apis}}{{#operations}}{{#operation}}
export class {{nickname}}Error extends Data.TaggedError("{{nickname}}Error")<{ message: string }> {}{{/operation}}{{/operations}}{{/apis}}{{/apiInfo}}

{{#apiInfo}}{{#apis}}{{#operations}}
{{#operation}}
/**
* {{&notes}}
{{#summary}}
* @summary {{&summary}}
{{/summary}}
{{#allParams}}
* @param {{=<% %>=}}{<%&dataType%>}<%={{ }}=%> {{^required}}[{{/required}}{{paramName}}{{^required}}]{{/required}} {{description}}
{{/allParams}}
*/
export const {{nickname}} = (dockerConnectionOptions: DockerConnectionOptions{{#allParams}}, {{paramName}}{{^required}}?{{/required}}: {{{dataType}}}{{/allParams}}): Effect.Effect<never, {{nickname}}Error | Http.error.HttpClientError {{#bodyParam}}| Http.body.BodyError {{/bodyParam}}| ParseResult.ParseError, {{#returnType}}Readonly<{{{returnType}}}>{{/returnType}}{{^returnType}}void{{/returnType}}> => Effect.gen(function* (_: Effect.Adapter) {
{{#allParams}}
{{#required}}
    if ({{paramName}} === null || {{paramName}} === undefined) {
        yield* _(new {{nickname}}Error({ message: "Required parameter {{paramName}} was null or undefined" }));
    }

{{/required}}
{{/allParams}}
    const endpoint: string = `${BASE_PATH}{{{path}}}`{{#pathParams}}.replace(`{${"{{baseName}}"}}`, encodeURIComponent(String({{paramName}}))){{/pathParams}};
    return Http.request.make("{{httpMethod}}")(endpoint);
})
{{#queryParams}}
{{#isListContainer}}
{{#isCollectionFormatMulti}}
.pipe(Effect.map(Http.request.setUrlParam("{{baseName}}", String({{paramName}}))))
{{/isCollectionFormatMulti}}
{{^isCollectionFormatMulti}}
.pipe(Effect.map(Http.request.setUrlParam("{{baseName}}", ({{paramName}} || []).join(COLLECTION_FORMATS["{{collectionFormat}}"]))))
{{/isCollectionFormatMulti}}
{{/isListContainer}}
{{^isListContainer}}
.pipe(Effect.map({{paramName}} === undefined ? identity : Http.request.setUrlParam("{{baseName}}", String({{paramName}}))))
{{/isListContainer}}
{{/queryParams}}
{{#headerParams}}
.pipe(Effect.map(Http.request.setHeader("{{baseName}}", String({{paramName}}))))
{{/headerParams}}
{{#bodyParam}}
{{^consumes}}
.pipe(Effect.map(Http.request.setHeader("Content-Type", "application/json")))
{{/consumes}}
{{#consumes.0}}
.pipe(Effect.map(Http.request.setHeader("Content-Type", "{{{mediaType}}}")))
{{/consumes.0}}
.pipe(
    Effect.flatMap((clientRequest) => {
        const needsSerialization =
            ("{{dataType}}" as unknown) !== "string" ||
            clientRequest.headers["Content-Type"] === "application/json";

        return needsSerialization
            ? Http.request.jsonBody(clientRequest, {{paramName}})
            : Effect.succeed(Http.request.textBody(clientRequest, ({{paramName}} as unknown as string) || ""));
    })
)
{{/bodyParam}}
.pipe(
    Effect.map(Http.request.prependUrl(makeUrl(dockerConnectionOptions))),
    Effect.flatMap(Http.client.fetchOk(makeDispatcher(dockerConnectionOptions)))
    {{#returnType}},Effect.flatMap(Http.response.schemaBodyJson({{{returnType}}}Schema)){{/returnType}}
)
{{/operation}}
{{/operations}}{{/apis}}{{/apiInfo}}

export interface IDockerService {
{{#apiInfo}}{{#apis}}{{#operations}}{{#operation}}readonly {{nickname}}: (...args: Parameters<typeof {{nickname}}> extends [DockerConnectionOptions, ...infer U] ? U : never) => ReturnType<typeof {{nickname}}>;
{{/operation}}{{/operations}}{{/apis}}{{/apiInfo}}
}

export const DefaultDockerService: Context.Tag<IDockerService, IDockerService> = Context.Tag<IDockerService>("defaultDockerService");

export const makeDockerService = (
    dockerConnectionOptions?: DockerConnectionOptions | undefined,
    contextTag: Context.Tag<IDockerService, IDockerService> = DefaultDockerService
): Layer.Layer<never, never, IDockerService> => {
    const localDockerConnectionOptions =
        dockerConnectionOptions ||
        ({
            protocol: "unix",
            socketPath: "/var/run/docker.sock",
        } as DockerConnectionOptions);

    return Layer.succeed(
        contextTag,
        contextTag.of({
{{#apiInfo}}{{#apis}}{{#operations}}{{#operation}}{{nickname}}: (...args: Parameters<typeof {{nickname}}> extends [DockerConnectionOptions, ...infer U] ? U : never) => {{nickname}}(localDockerConnectionOptions, ...args),
{{/operation}}{{/operations}}{{/apis}}{{/apiInfo}}
        })
    );
}
